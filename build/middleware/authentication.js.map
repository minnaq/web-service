{"version":3,"sources":["../../source/middleware/authentication.js"],"names":["authentication","keys","validate_token","get_jwt_token","token","error","authenticate","Unauthenticated","role","payload","user_id","jwt","secret","verify","name","authentication_error","jwt_id","jti","sub","is_valid","valid","user","id","token_data","roles","Unauthorized","isValid","options","ctx","next","call","isAuth","issue_jwt_token","context","header","authorization","match","arguments","length","Error","sign","subject","jwtid"],"mappings":"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","file":"authentication.js","sourcesContent":["import jwt from 'jsonwebtoken'\n\nimport errors from '../errors'\n\n// Looks for JWT token inside HTTP Authorization header\nfunction get_jwt_token(context)\n{\n\t// Parses \"Authorization: Bearer ${token}\"\n\tif (context.header.authorization)\n\t{\n\t\tconst match = context.header.authorization.match(/^Bearer (.+)$/i)\n\n\t\tif (match)\n\t\t{\n\t\t\treturn { token: match[1] }\n\t\t}\n\n\t\t// return { error: 'Bad Authorization header format. Format is \"Authorization: Bearer <token>\"' }\n\t}\n\n\t// (doesn't read cookies anymore to protect users from CSRF attacks)\n\t// // Tries the \"authentication\" cookie\n\t// if (context.cookies.get('authentication'))\n\t// {\n\t// \treturn { token: context.cookies.get('authentication') }\n\t// }\n\n\t// No JWT token was found\n\treturn { error: `JWT token not found: no \"Authorization: Bearer {token}\" HTTP header specified.` }\n}\n\n// Looks for JWT token, and if it is found, sets some variables.\nasync function authenticate({ authentication, keys, validate_token })\n{\n\t// Get JWT token from incoming HTTP request\n\tconst { token, error } = get_jwt_token(this)\n\n\t// Little helpers which can be called from routes to ensure\n\t// a logged in user or a specific user role\n\tthis.authenticate = () => { throw new errors.Unauthenticated() }\n\tthis.role         = () => { throw new errors.Unauthenticated() }\n\n\tlet payload, user_id\n\tif(token) {\n\n\t\t// If no JWT token was found, then done\n\t\t// if (!token)\n\t\t// {\n\t\t// \tthis.authentication_error = new errors.Unauthenticated(error)\n\t\t// \treturn\n\t\t// }\n\n\t\t// JWT token (is now accessible from Koa's `ctx`)\n\t\tthis.jwt = token\n\n\t\t// Verify JWT token integrity\n\t\t// by checking its signature using the supplied `keys`\n\n\t\t// let payload\n\n\t\tfor (let secret of keys)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tpayload = jwt.verify(token, secret)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\t// if authentication token expired\n\t\t\t\tif (error.name === 'TokenExpiredError')\n\t\t\t\t{\n\t\t\t\t\tthis.authentication_error = new errors.Unauthenticated('Token expired')\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// try another `secret`\n\t\t\t\tif (error.name === 'JsonWebTokenError')\n\t\t\t\t{\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// some other error\n\t\t\t\tthrow error\n\t\t\t}\n\t\t}\n\n\t\t// If JWT token signature was unable to be verified, then exit\n\t\tif (!payload)\n\t\t{\n\t\t\tthis.authentication_error = new errors.Unauthenticated('Corrupt token')\n\t\t\treturn\n\t\t}\n\n\t\t// JWT token ID\n\t\tconst jwt_id = payload.jti\n\n\t\t// `subject`\n\t\t// (which is a user id)\n\t\t// const user_id = payload.sub\n\t\tuser_id = payload.sub\n\n\t\t// Optional JWT token validation (by id)\n\t\t// (for example, that it has not been revoked)\n\t\tif (validate_token)\n\t\t{\n\t\t\t// Can validate the token via a request to a database, for example.\n\t\t\t// Checks for `valid` property value inside the result object.\n\t\t\t// (There can possibly be other properties such as `reason`)\n\t\t\tconst is_valid = (await validate_token(token, this)).valid\n\n\t\t\t// If the JWT token happens to be invalid\n\t\t\t// (expired or revoked, for example), then exit.\n\t\t\tif (!is_valid)\n\t\t\t{\n\t\t\t\tthis.authentication_error = new errors.Unauthenticated(`Token revoked`)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// JWT token ID is now accessible via Koa's `ctx`\n\t\tthis.jwt_id = jwt_id\n\t}\n\n\t// Extracts user data (description) from JWT token payload\n\t// (`user` is now accessible via Koa's `ctx`)\n\t// this.user = authentication ? authentication(payload) : {}\n\t// tim huang 修改于 2017-03-03\n\tthis.user = authentication ? await authentication(payload, this) : {}\n\n\t// Sets user id\n\tthis.user.id = user_id\n\n\t// Extra payload fields:\n\t//\n\t// 'iss' // Issuer\n\t// 'sub' // Subject\n\t// 'aud' // Audience\n\t// 'exp' // Expiration time\n\t// 'nbf' // Not before\n\t// 'iat' // Issued at\n\t// 'jti' // JWT ID\n\n\t// JWT token payload is accessible via Koa's `ctx`\n\tthis.token_data = payload\n\n\t// The user is assumed authenticated now,\n\t// so `this.authenticate()` helper won't throw an exception.\n\t// (and will return the `user`)\n\tthis.authenticate = () => this.user\n\n\t// A little helper which can be called from routes\n\t// as `this.role('administrator')`\n\t// which will throw if the user isn't administrator\n\t// (`authentication` function needs to get\n\t//  `role` from JWT payload for this to work)\n\tthis.role = (...roles) =>\n\t{\n\t\tfor (let role of roles)\n\t\t{\n\t\t\tif (this.user.role === role)\n\t\t\t{\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tthrow new errors.Unauthorized(`One of the following roles is required: ${roles}`)\n\t}\n\n\t// tim huang 修改于 2017-03-03\n\treturn this.user.isValid !== false\n}\n\n// Koa middleware creator\nexport default function(options)\n{\n\t// Koa middleware\n\treturn async function(ctx, next)\n\t{\n\t\t// tim huang 修改于 2017-03-03\n\n\t\tconst isAuth = await authenticate.call(ctx, options)\n\t\tif(isAuth) {\n\t\t\tawait next()\n\t\t}\n\t}\n}\n\n// Generates and signs a JWT token\nexport function issue_jwt_token({ payload, keys, user_id, jwt_id })\n{\n\tif (arguments.length !== 1)\n\t{\n\t\tthrow new Error(\"`jwt` function must take a single argument: an object { payload, keys, user_id, jwt_id }\")\n\t}\n\n\tif (!keys)\n\t{\n\t\tthrow new Error(`JWT encryption \"keys\" weren't supplied`)\n\t}\n\n\tconst token = jwt.sign(payload, keys[0],\n\t{\n\t\tsubject : user_id,\n\t\tjwtid   : jwt_id\n\t})\n\n\treturn token\n}\n"]}