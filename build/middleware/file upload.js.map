{"version":3,"sources":["../../source/middleware/file upload.js"],"names":["folder","options","file_name","sync","fs_exists","join","exists","on_collision","generate_unique_filename","file","upload_folder","log","debug","filename","info","output_file","resolve","reject","ensureDir","error","stream","createWriteStream","pipe","on","relative","upload_file","parameters","mount_path","path","at","to","requires_authentication","on_file_uploaded","process","respond","multiple_files","multiple","file_size_limit","limit","ctx","is","Unsupported_input_type","user","Unauthenticated","req","limits","fileSize","undefined","form_data","files","fields","file_upload_promises","not_empty","Error","file_upload_promise","res","then","file_path","original_file_name","uploaded_file_name","ip","request","result","push","all","file_upload_results","response","call","body"],"mappings":"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","file":"file upload.js","sourcesContent":["import path from 'path'\nimport fs from 'fs-extra'\n\n// https://github.com/cojs/busboy/issues/30\n// https://github.com/brentburg/chan/pull/18\nimport busboy           from 'async-busboy'\nimport file_size_parser from 'filesize-parser'\nimport mount            from 'koa-mount'\nimport uid              from 'uid-safe'\n\nimport promisify from '../promisify'\nimport errors    from '../errors'\n\nexport default function(...parameters)\n{\n\tlet mount_path\n\tlet upload_folder\n\tlet options\n\tlet log\n\n\t// New API\n\tif (typeof parameters[0] === 'string')\n\t{\n\t\tmount_path    = parameters[0]\n\t\tupload_folder = parameters[1]\n\t\toptions       = parameters[2]\n\t\tlog           = parameters[3]\n\t}\n\t// Old API\n\telse\n\t{\n\t\toptions       = parameters[0]\n\t\tlog           = parameters[1]\n\t\tmount_path    = options.path || options.mount_path || options.at || '/'\n\t\tupload_folder = options.to || options.upload_folder\n\t}\n\n\tconst\n\t{\n\t\trequires_authentication = false,\n\t\ton_file_uploaded,\n\t\tprocess,\n\t\tstream,\n\t\trespond\n\t}\n\t= options\n\n\tconst multiple_files  = options.multiple_files || options.multiple\n\tconst file_size_limit = options.file_size_limit || options.limit\n\n\treturn mount(mount_path, async function(ctx)\n\t{\n\t\t// Only \"multipart/form-data\" HTTP POST requests are allowed\n\t\tif (!ctx.is('multipart/form-data'))\n\t\t{\n\t\t\tthrow new errors.Unsupported_input_type(`This is supposed to be a \"multipart/form-data\" http request`)\n\t\t}\n\n\t\t// If authentication is required, and the user is not authenticated, then abort\n\t\tif (requires_authentication !== false && !ctx.user)\n\t\t{\n\t\t\tthrow new errors.Unauthenticated()\n\t\t}\n\n\t\t// Initialize `busboy` streamer\n\t\tconst form_data = await busboy(ctx.req,\n\t\t{\n\t\t\tlimits:\n\t\t\t{\n\t\t\t\tfileSize: file_size_limit ? file_size_parser(file_size_limit) : undefined\n\t\t\t}\n\t\t})\n\n\t\t// This is a non-channel approach, since `chan` package\n\t\t// currently doesn't support `async/await`.\n\t\t//\n\t\t// The consequence is that files are written to disk twice.\n\t\t// First, `async-busboy` writes them to disk\n\t\t// and waits for that to finish.\n\t\t// Second, `upload_file` reads those file streams\n\t\t// and writes them to the `upload_folder`.\n\t\t//\n\t\t// This bug will be fixed once they release\n\t\t// a `co-busboy` alternative for Koa 2 (`async/await`).\n\t\t// In the meantime I'm using `async-busboy` just to get it working.\n\t\t//\n\t\t// See:\n\t\t// https://github.com/cojs/busboy/issues/30\n\t\t// https://github.com/brentburg/chan/pull/18\n\t\t//\n\t\t// `co-busboy` can be easily rewrote with async channels.\n\t\t//\n\t\t// Currently it just waits for all files to be written to disk,\n\t\t// and then get that `{ files, fields }` result object.\n\t\t//\n\t\tconst { files, fields } = form_data\n\t\tconst parameters = fields\n\n\t\tconst file_upload_promises = []\n\n\t\t// `co-busboy` asynchronous approach (old code)\n\t\t// let form_data_item\n\t\t// while (form_data_item = yield form_data) { ... }\n\n\t\t// Synchronous approach (after all files have been uploaded)\n\t\tfor (let file of files)\n\t\t{\n\t\t\t// Checks if multiple file upload is allowed\n\t\t\tif (!multiple_files && file_upload_promises.not_empty())\n\t\t\t{\n\t\t\t\tthrow new Error(`Multiple files are being uploaded to a single file upload endpoint`)\n\t\t\t}\n\n\t\t\t// Old `co-busboy` code\n\t\t\t// if (Array.isArray(form_data_item))\n\t\t\t// {\n\t\t\t// \tparameters[form_data_item[0]] = form_data_item[1]\n\t\t\t// \tcontinue\n\t\t\t// }\n\n\t\t\tlet file_upload_promise\n\n\t\t\t// Custom low-level uploaded stream handling logic\n\t\t\tif (stream)\n\t\t\t{\n\t\t\t\t// `file` is a `ReadableStream`.\n\t\t\t\t//\n\t\t\t\t// If the resolved value should be later sent back in HTTP response,\n\t\t\t\t// then `stream` must return a Promise,\n\t\t\t\t// and also `respond` parameter must not be `false`.\n\t\t\t\t// The third parameter of the `stream` function is ignored in this case.\n\t\t\t\t//\n\t\t\t\t// If the user of this library wants to stream HTTP response instead\n\t\t\t\t// then the `respond` parameter should be set to `false`\n\t\t\t\t// and the response data should be streamed to the third parameter\n\t\t\t\t// of the `stream` function (which is a regular Node.js `http.ServerResponse`)\n\t\t\t\t// \n\t\t\t\tfile_upload_promise = stream(file, parameters, ctx.res)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Upload each file and `process` it (if needed)\n\t\t\t\tfile_upload_promise = upload_file(file, { upload_folder, log }).then(async file_name =>\n\t\t\t\t{\n\t\t\t\t\tconst file_path = path.join(upload_folder, file_name)\n\n\t\t\t\t\t// Fire `on_file_uploaded` listener\n\t\t\t\t\tif (on_file_uploaded)\n\t\t\t\t\t{\n\t\t\t\t\t\t// `ctx.request.ip` trusts X-Forwarded-For HTTP Header\n\t\t\t\t\t\ton_file_uploaded\n\t\t\t\t\t\t({\n\t\t\t\t\t\t\toriginal_file_name : file.filename,\n\t\t\t\t\t\t\tuploaded_file_name : file_name,\n\t\t\t\t\t\t\tpath               : file_path,\n\t\t\t\t\t\t\tip                 : ctx.request.ip\n\t\t\t\t\t\t},\n\t\t\t\t\t\tparameters)\n\t\t\t\t\t}\n\n\t\t\t\t\t// `process` the file (if needed), returning a result\n\t\t\t\t\tif (process)\n\t\t\t\t\t{\n\t\t\t\t\t\t// `ctx.request.ip` trusts X-Forwarded-For HTTP Header\n\t\t\t\t\t\treturn await process\n\t\t\t\t\t\t({\n\t\t\t\t\t\t\toriginal_file_name : file.filename,\n\t\t\t\t\t\t\tuploaded_file_name : file_name,\n\t\t\t\t\t\t\tpath               : file_path,\n\t\t\t\t\t\t\tip                 : ctx.request.ip\n\t\t\t\t\t\t},\n\t\t\t\t\t\tparameters)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Default result\n\t\t\t\t\tconst result =\n\t\t\t\t\t{\n\t\t\t\t\t\toriginal_file_name: file.filename,\n\t\t\t\t\t\tuploaded_file_name: file_name\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tfile_upload_promises.push(file_upload_promise)\n\t\t}\n\n\t\t// If the `respond` parameter was set to `false`\n\t\t// then it means that the user of the library\n\t\t// chose to stream HTTP response manually,\n\t\t// so write nothing to `ctx.body`\n\t\tif (respond === false)\n\t\t{\n\t\t\treturn\n\t\t}\n\n\t\t// Wait for all files to be uploaded and `process`ed\n\t\tconst file_upload_results = await Promise.all(file_upload_promises)\n\n\t\t// Default HTTP response\n\n\t\tlet response\n\n\t\tif (process)\n\t\t{\n\t\t\tif (multiple_files)\n\t\t\t{\n\t\t\t\tresponse = file_upload_results\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresponse = file_upload_results[0]\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (multiple_files)\n\t\t\t{\n\t\t\t\tresponse = { files: file_upload_results, parameters }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresponse = { file: file_upload_results[0], parameters }\n\t\t\t}\n\t\t}\n\n\t\t// Optionally modify the HTTP response\n\t\tif (respond)\n\t\t{\n\t\t\tresponse = respond.call(this, response)\n\t\t}\n\n\t\t// HTTP response\n\t\tctx.body = response\n\t})\n}\n\n// Checks if the filesystem `path` exists.\n// Returns a Promise resolving to either `true` or `false`.\nfunction fs_exists(path)\n{\n\treturn new Promise((resolve, reject) => \n\t{\n\t\tfs.exists(path, exists => resolve(exists))\n\t})\n}\n\n// Generates a unique temporary file name inside the `folder` path.\n// Returns a Promise resolving to the randomly generated filename.\nexport async function generate_unique_filename(folder, options)\n{\n\t// 24 bytes for UUID filename\n\tlet file_name = uid.sync(24)\n\n\t// Check if a file with such a name exists\n\tconst exists = await fs_exists(path.join(folder, file_name))\n\n\t// If no such file exists yet,\n\t// then this filename is considered unique.\n\tif (!exists)\n\t{\n\t\treturn file_name\n\t}\n\n\t// If a file with this name already exists, then retry\n\n\tif (options.on_collision)\n\t{\n\t\toptions.on_collision(file_name)\n\t}\n\n\treturn await generate_unique_filename(folder, options)\n}\n\n// Handles file upload.\n// Takes a `file` busboy file object\n// along with `upload_folder` option.\n// Writes the `file` stream to `upload_folder`\n// naming it with a randomly generated filename.\n//\n// Returns a Promise resolving to the randomly generated filename.\n//\nasync function upload_file(file, { upload_folder, log })\n{\n\tif (log)\n\t{\n\t\tlog.debug(`Uploading: ${file.filename}`)\n\t}\n\n\t// Generate random unique filename\n\tconst file_name = await generate_unique_filename(upload_folder,\n\t{\n\t\ton_collision: (file_name) =>\n\t\t{\n\t\t\tlog.info(`Generate unique file name: collision for \"${file_name}\". Taking another try.`)\n\t\t}\n\t})\n\n\t// dot_extension: path.extname(file.filename)\n\n\tconst output_file = path.join(upload_folder, file_name)\n\n\t// Write the file to disk\n\treturn await new Promise((resolve, reject) =>\n\t{\n\t\t// Ensure the `upload_folder` exists\n\t\t// (just an extra precaution)\n\t\tfs.ensureDir(upload_folder, (error) =>\n\t\t{\n\t\t\tif (error)\n\t\t\t{\n\t\t\t\treturn reject(error)\n\t\t\t}\n\n\t\t\t// Open output file stream\n\t\t\tconst stream = fs.createWriteStream(output_file)\n\n\t\t\t// Pipe file contents to disk\n\t\t\tfile.pipe(stream)\n\t\t\t\t.on('finish', () => resolve(path.relative(upload_folder, output_file)))\n\t\t\t\t.on('error', error => reject(error))\n\t\t})\n\t})\n}"]}