{"version":3,"sources":["../../../../source/deprecated/koa-generic-session/lib/session.js"],"names":["debug","require","MemoryStore","crc32","parse","Store","copy","uid","warning","defaultCookie","httpOnly","path","overwrite","signed","maxAge","module","exports","options","getSession","refreshSession","session","deferSession","key","client","store","errorHandler","defaultErrorHanlder","reconnectTimeout","cookie","to","compatMaxage","ttl","prefix","genSid","sync","valid","noop","beforeSave","storeStatus","waitStore","resolve","process","env","NODE_ENV","console","warn","sessionIdStore","get","cookies","set","sid","reset","on","reject","setTimeout","Error","once","EMPTY_SESSION_HASH","hash","generateSession","defer","matchPath","ctx","pathname","indexOf","sessionId","call","isNew","code","message","originalHash","destroy","newHash","allowEmpty","rolling","bump","next","sessionStore","_session","result","__defineGetter__","__defineSetter__","sess","regenerateSession","touchSession","getter","value","opts","maxage","undefined","err","type","name"],"mappings":"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","file":"session.js","sourcesContent":["/**!\n * koa-generic-session - lib/session.js\n * Copyright(c) 2013 - 2014\n * MIT Licensed\n *\n * Authors:\n *   dead_horse <dead_horse@qq.com> (http://deadhorse.me)\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst debug = require('debug')('koa-generic-session:session');\nconst MemoryStore = require('./memory_store');\nconst crc32 = require('crc').crc32;\nconst parse = require('parseurl');\nconst Store = require('./store');\nconst copy = require('copy-to');\nconst uid = require('uid-safe');\n\n/**\n * Warning message for `MemoryStore` usage in production.\n */\n\nconst warning = 'Warning: koa-generic-session\\'s MemoryStore is not\\n' +\n  'designed for a production environment, as it will leak\\n' +\n  'memory, and will not scale past a single process.';\n\nconst defaultCookie = {\n  httpOnly: true,\n  path: '/',\n  overwrite: true,\n  signed: true,\n  maxAge: 24 * 60 * 60 * 1000 //one day in ms\n};\n\n/**\n * setup session store with the given `options`\n * @param {Object} options\n *   - [`key`] cookie name, defaulting to `koa.sid`\n *   - [`store`] session store instance, default to MemoryStore\n *   - [`ttl`] store ttl in `ms`, default to oneday\n *   - [`prefix`] session prefix for store, defaulting to `koa:sess:`\n *   - [`cookie`] session cookie settings, defaulting to\n *     {path: '/', httpOnly: true, maxAge: null, rewrite: true, signed: true}\n *   - [`defer`] defer get session,\n *   - [`rolling`]  rolling session, always reset the cookie and sessions, default is false\n *     you should `yield this.session` to get the session if defer is true, default is false\n *   - [`genSid`] you can use your own generator for sid\n *   - [`errorHanlder`] handler for session store get or set error\n *   - [`valid`] valid(ctx, session), valid session value before use it\n *   - [`beforeSave`] beforeSave(ctx, session), hook before save session\n *   - [`sessionIdStore`] object with get, set, reset methods for passing session id throw requests.\n */\n\nmodule.exports = function (options) {\n  options = options || {};\n  let key = options.key || 'koa.sid';\n  let client = options.store || new MemoryStore();\n  let errorHandler = options.errorHandler || defaultErrorHanlder;\n  let reconnectTimeout = options.reconnectTimeout || 10000;\n\n  let cookie = options.cookie || {};\n  copy(defaultCookie).to(cookie);\n  compatMaxage(cookie);\n\n  let store = new Store(client, {\n    ttl: options.ttl,\n    prefix: options.prefix,\n    cookie: cookie\n  });\n\n  let genSid = options.genSid || uid.sync;\n  let valid = options.valid || noop;\n  let beforeSave = options.beforeSave || noop;\n\n  let storeStatus = 'available';\n  let waitStore = Promise.resolve();\n\n  // notify user that this store is not\n  // meant for a production environment\n  if ('production' === process.env.NODE_ENV\n   && client instanceof MemoryStore) console.warn(warning);\n\n  let sessionIdStore = options.sessionIdStore || {\n\n    get: function() {\n      return this.cookies.get(key, cookie);\n    },\n\n    set: function(sid, session) {\n      this.cookies.set(key, sid, cookie);\n    },\n\n    reset: function() {\n      this.cookies.set(key, null);\n      this.cookies.set(key + '.sig', null);\n    }\n  };\n\n  store.on('disconnect', function() {\n    if (storeStatus !== 'available') return;\n    storeStatus = 'pending';\n    waitStore = new Promise(function (resolve, reject) {\n      setTimeout(function () {\n        if (storeStatus === 'pending') storeStatus = 'unavailable';\n        reject(new Error('session store is unavailable'));\n      }, reconnectTimeout);\n      store.once('connect', resolve);\n    });\n\n  });\n\n  store.on('connect', function() {\n    storeStatus = 'available';\n    waitStore = Promise.resolve();\n  });\n\n  // save empty session hash for compare\n  const EMPTY_SESSION_HASH = hash(generateSession());\n\n  return options.defer ? deferSession : session;\n\n  /**\n   * generate a new session\n   */\n  function generateSession() {\n    let session = {};\n    // //you can alter the cookie options in nexts\n    // session.cookie = {};\n    // for (let prop in cookie) {\n    //   session.cookie[prop] = cookie[prop];\n    // }\n    // compatMaxage(session.cookie);\n    return session;\n  }\n\n  /**\n   * check url match cookie's path\n   */\n  function matchPath(ctx) {\n    let pathname = parse(ctx).pathname;\n    if (pathname.indexOf(cookie.path || '/') !== 0) {\n      debug('cookie path not match');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * get session from store\n   *   get sessionId from cookie\n   *   save sessionId into context\n   *   get session from store\n   */\n  function *getSession() {\n    if (!matchPath(this)) return;\n    if (storeStatus === 'pending') {\n      debug('store is disconnect and pending');\n      yield waitStore;\n    } else if (storeStatus === 'unavailable') {\n      debug('store is unavailable');\n      throw new Error('session store is unavailable');\n    }\n\n    if (!this.sessionId) {\n      this.sessionId = sessionIdStore.get.call(this);\n    }\n\n    let session;\n    let isNew = false;\n    if (!this.sessionId) {\n      debug('session id not exist, generate a new one');\n      session = generateSession();\n      this.sessionId = yield Promise.resolve(genSid.call(this, 24));\n      isNew = true;\n    } else {\n      try {\n        session = yield store.get(this.sessionId);\n        debug('get session %j with key %s', session, this.sessionId);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          debug('get session error, code = ENOENT');\n        } else {\n          debug('get session error: ', err.message);\n          errorHandler(err, 'get', this);\n        }\n      }\n    }\n\n    // make sure the session is still valid\n    if (!session ||\n      !valid(this, session)) {\n      debug('session is empty or invalid');\n      session = generateSession();\n      this.sessionId = yield Promise.resolve(genSid.call(this, 24));\n      sessionIdStore.reset.call(this);\n      isNew = true;\n    }\n\n    // get the originHash\n    let originalHash = !isNew && hash(session);\n\n    return {\n      originalHash: originalHash,\n      session: session,\n      isNew: isNew\n    };\n  }\n\n  /**\n   * after everything done, refresh the session\n   *   if session === null; delete it from store\n   *   if session is modified, update cookie and store\n   *   if session is not modified, update cookie maxAge and store TTL\n   */\n  function *refreshSession (session, originalHash, isNew) {\n    //delete session\n    if (!session) {\n      if (!isNew) {\n        debug('session set to null, destroy session: %s', this.sessionId);\n        sessionIdStore.reset.call(this);\n        return yield store.destroy(this.sessionId);\n      }\n      return debug('a new session and set to null, ignore destroy');\n    }\n\n    let newHash = hash(session);\n    // if new session and not modified, just ignore\n    if (!options.allowEmpty && isNew && newHash === EMPTY_SESSION_HASH) {\n      return debug('new session and do not modified');\n    }\n\n    // rolling session will always reset cookie and session\n    if (options.rolling) {\n      return;\n    }\n\n    // compatMaxage(session.cookie);\n\n    if (newHash === originalHash) {\n      debug('session not modified');\n\n      // prolong session: update session TTL and session cookie maxAge\n      try {\n        yield store.bump(this.sessionId);\n        sessionIdStore.set.call(this, this.sessionId, session);\n        debug('session prolonged');\n      } catch (err) {\n        debug('prolong session error: ', err.message);\n        errorHandler(err, 'prolong', this);\n      }\n\n      return;\n    }\n\n    debug('session modified');\n\n    // custom before save hook\n    beforeSave(this, session);\n\n    //update session\n    try {\n      yield store.set(this.sessionId, session);\n      sessionIdStore.set.call(this, this.sessionId, session);\n      debug('saved');\n    } catch (err) {\n      debug('set session error: ', err.message);\n      errorHandler(err, 'set', this);\n    }\n  }\n\n  /**\n   * common session middleware\n   * each request will generate a new session\n   *\n   * ```\n   * let session = this.session;\n   * ```\n   */\n  function *session(next) {\n    this.sessionStore = store;\n    if (this._session) {\n      return yield next;\n    }\n    let result = yield getSession.call(this);\n    if (!result) {\n      return yield next;\n    }\n\n    this._session = result.session;\n\n    // more flexible\n    this.__defineGetter__('session', function () {\n      return this._session;\n    });\n\n    this.__defineSetter__('session', function (sess) {\n      this._session = sess;\n    });\n\n    this.regenerateSession = function *regenerateSession() {\n      debug('regenerating session');\n      if (!result.isNew) {\n        // destroy the old session\n        debug('destroying previous session');\n        yield store.destroy(this.sessionId);\n      }\n\n      this.session = generateSession();\n      this.sessionId = genSid.call(this, 24);\n      sessionIdStore.reset.call(this);\n\n      debug('created new session: %s', this.sessionId);\n      result.isNew = true;\n    }\n\n    yield next;\n    yield refreshSession.call(this, this.session, result.originalHash, result.isNew);\n  }\n\n  /**\n   * defer session middleware\n   * only generate and get session when request use session\n   *\n   * ```\n   * let session = yield this.session;\n   * ```\n   */\n  function *deferSession(next) {\n    this.sessionStore = store;\n\n    if (this.session) {\n      return yield next;\n    }\n    let isNew = false;\n    let originalHash = null;\n    let touchSession = false;\n    let getter = false;\n\n    // if path not match\n    if (!matchPath(this)) {\n      return yield next;\n    }\n\n    this.__defineGetter__('session', function *() {\n      if (touchSession) {\n        return this._session;\n      }\n      touchSession = true;\n      getter = true;\n\n      let result = yield getSession.call(this);\n      // if cookie path not match\n      // this route's controller should never use session\n      if (!result) return;\n\n      originalHash = result.originalHash;\n      isNew = result.isNew;\n      this._session = result.session;\n      return this._session;\n    });\n\n    this.__defineSetter__('session', function (value) {\n      touchSession = true;\n      this._session = value;\n    });\n\n    this.regenerateSession = function *regenerateSession() {\n      debug('regenerating session');\n      // make sure that the session has been loaded\n      yield this.session;\n\n      if (!isNew) {\n        // destroy the old session\n        debug('destroying previous session');\n        yield store.destroy(this.sessionId);\n      }\n\n      this._session = generateSession();\n      this.sessionId = genSid.call(this, 24);\n      sessionIdStore.reset.call(this);\n      debug('created new session: %s', this.sessionId);\n      isNew = true;\n      return this._session;\n    }\n\n    yield next;\n\n    if (touchSession) {\n      // if only this.session=, need try to decode and get the sessionID\n      if (!getter) {\n        this.sessionId = sessionIdStore.get.call(this);\n      }\n\n      yield refreshSession.call(this, this._session, originalHash, isNew);\n    }\n  }\n};\n\n/**\n * get the hash of a session include cookie options.\n */\nfunction hash(sess) {\n  return crc32.signed(JSON.stringify(sess));\n}\n\n/**\n * cookie use maxage, hack to compat connect type `maxAge`\n */\nfunction compatMaxage(opts) {\n  if (opts) {\n    opts.maxage = opts.maxage === undefined\n      ? opts.maxAge\n      : opts.maxage;\n    delete opts.maxAge;\n  }\n}\n\nmodule.exports.MemoryStore = MemoryStore;\n\nfunction defaultErrorHanlder (err, type, ctx) {\n  err.name = 'koa-generic-session ' + type + ' error';\n  throw err;\n}\n\nfunction noop () {\n  return true;\n}\n"]}