{"version":3,"sources":["../source/helpers.js"],"names":["is_object","extend","starts_with","ends_with","is_empty","not_empty","exists","what","object_constructor","constructor","object","objects","filter","x","length","to","from","last","pop","intermediary_result","apply","key","Array","isArray","concat","clone","string","substring","j","i","array"],"mappings":"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","file":"helpers.js","sourcesContent":["// // if the variable is defined\nexport const exists = what => typeof what !== 'undefined'\n\n// used for JSON object type checking\nconst object_constructor = {}.constructor\n\n// detects a JSON object\nexport function is_object(object)\n{\n\treturn exists(object) && (object !== null) && object.constructor === object_constructor\n}\n\n// extends the first object with \n/* istanbul ignore next: some weird transpiled code, not testable */\nexport function extend(...objects)\n{\n\tobjects = objects.filter(x => exists(x))\n\n\tif (objects.length === 0)\n\t{\n\t\treturn\n\t}\n\t\n\tif (objects.length === 1)\n\t{\n\t\treturn objects[0]\n\t}\n\n\tconst to   = objects[0]\n\tconst from = objects[1]\n\n\tif (objects.length > 2)\n\t{\n\t\tconst last = objects.pop()\n\t\tconst intermediary_result = extend.apply(this, objects)\n\t\treturn extend(intermediary_result, last)\n\t}\n\n\tfor (let key of Object.keys(from))\n\t{\n\t\tif (is_object(from[key]))\n\t\t{\n\t\t\tif (!is_object(to[key]))\n\t\t\t{\n\t\t\t\tto[key] = {}\n\t\t\t}\n\n\t\t\textend(to[key], from[key])\n\t\t}\n\t\telse if (Array.isArray(from[key]))\n\t\t{\n\t\t\tif (!Array.isArray(to[key]))\n\t\t\t{\n\t\t\t\tto[key] = []\n\t\t\t}\n\n\t\t\tto[key] = to[key].concat(clone(from[key]))\n\t\t}\n\t\telse\n\t\t{\n\t\t\tto[key] = from[key]\n\t\t}\n\t}\n\n\treturn to\n}\n\nexport function starts_with(string, substring)\n{\n\tlet j = substring.length\n\n\tif (j > string.length)\n\t{\n\t\treturn false\n\t}\n\n\twhile (j > 0)\n\t{\n\t\tj--\n\n\t\tif (string[j] !== substring[j])\n\t\t{\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nexport function ends_with(string, substring)\n{\n\tlet i = string.length\n\tlet j = substring.length\n\n\tif (j > i)\n\t{\n\t\treturn false\n\t}\n\n\twhile (j > 0)\n\t{\n\t\ti--\n\t\tj--\n\n\t\tif (string[i] !== substring[j])\n\t\t{\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nexport function is_empty(array)\n{\n\treturn array.length === 0\n}\n\nexport function not_empty(array)\n{\n\treturn array.length > 0\n}\n"]}